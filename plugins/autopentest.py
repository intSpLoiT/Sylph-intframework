import os
import importlib.util
import json
import subprocess
import shlex
import base64

class ExploitPlugin:
    name = "exploit_plugin"
    commands = {
        "load_exploit": {
            "func": lambda args: ExploitPlugin.load_exploit(args),
            "desc": "Load an exploit module from a given path.",
            "usage": "load_exploit <module_path>"
        },
        "set_option": {
            "func": lambda args: ExploitPlugin.set_option(args),
            "desc": "Set an option for the loaded exploit module.",
            "usage": "set_option <option_name> <value>"
        },
        "show_options": {
            "func": lambda args: ExploitPlugin.show_options(),
            "desc": "Show current options of the loaded exploit.",
            "usage": "show_options"
        },
        "run_exploit": {
            "func": lambda args: ExploitPlugin.run_module(),
            "desc": "Run the loaded exploit module.",
            "usage": "run_exploit"
        }
    }

    module_context = {}
    option_schema = {}
    loaded_module_path = None
    DB_PATH = "db/set.int4"

    @classmethod
    def load_exploit(cls, args):
        if not args:
            return "[!] Usage: load_exploit <module_path>"
        module_path = args[0]
        if not os.path.exists(module_path):
            return f"[!] Module path not found: {module_path}"

        cls.loaded_module_path = module_path
        spec = importlib.util.spec_from_file_location("module", module_path)
        mod = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(mod)
        cls.option_schema = getattr(mod, "option_schema", {})
        cls.load_context()
        return f"[+] Schema loaded from {module_path}"

    @classmethod
    def set_option(cls, args):
        if len(args) < 2:
            return "[!] Usage: set_option <key> <value>"
        key, value = args[0].lower(), args[1]
        if key in cls.option_schema:
            cls.module_context[key] = value
            cls.save_context()
            return f"[+] Option set: {key} = {value}"
        else:
            return f"[!] Invalid option: {key}"

    @classmethod
    def save_context(cls):
        os.makedirs(os.path.dirname(cls.DB_PATH), exist_ok=True)
        with open(cls.DB_PATH, "w") as f:
            json.dump(cls.module_context, f)

    @classmethod
    def load_context(cls):
        if os.path.exists(cls.DB_PATH):
            with open(cls.DB_PATH, "r") as f:
                cls.module_context = json.load(f)
        else:
            cls.module_context = {}

    @classmethod
    def show_options(cls):
        lines = []
        lines.append("\nOptions:")
        lines.append(f"{'Name':<15} {'Current':<20} {'Required':<10} Description")
        lines.append("-" * 60)
        for key, meta in cls.option_schema.items():
            current = cls.module_context.get(key, meta.get("default", ""))
            required = "yes" if meta.get("required", False) else "no"
            desc = meta.get("description", "")
            lines.append(f"{key:<15} {str(current):<20} {required:<10} {desc}")
        return "\n".join(lines)

    @classmethod
    def validate_required(cls):
        missing = []
        for key, meta in cls.option_schema.items():
            if meta.get("required") and not cls.module_context.get(key) and not meta.get("default"):
                missing.append(key)
        if missing:
            return f"[!] Missing required options: {', '.join(missing)}"
        return None

    @classmethod
    def run_module(cls):
        if not cls.loaded_module_path:
            return "[!] No module loaded. Please load a module first."
        missing = cls.validate_required()
        if missing:
            return missing + "\n[!] Cannot run module due to missing required options."

        interpreter = None
        if cls.loaded_module_path.endswith(".py"):
            interpreter = "python3"
        elif cls.loaded_module_path.endswith(".sh"):
            interpreter = "bash"
        else:
            return "[!] Unsupported module extension."

        cmd = [interpreter, cls.loaded_module_path]
        for key in cls.option_schema.keys():
            val = cls.module_context.get(key)
            if val:
                cmd.append(str(val))

        uses_input = False
        if cls.loaded_module_path.endswith(".py"):
            with open(cls.loaded_module_path, "r", encoding="utf-8") as f:
                uses_input = "input(" in f.read()

        if uses_input:
            import pexpect
            child = pexpect.spawn(" ".join(shlex.quote(arg) for arg in cmd))
            child.interact()
            return "[*] Interactive module session finished."
        else:
            proc = subprocess.run(cmd, capture_output=True, text=True)
            if proc.returncode == 0:
                return "[+] Module executed successfully.\n\n" + proc.stdout
            else:
                return "[!] Module execution failed:\n" + proc.stderr


class PayloadPlugin:
    name = "payload_plugin"
    commands = {
        "list_payloads": {
            "func": lambda args: PayloadPlugin.list_payloads(),
            "desc": "List available payload modules.",
            "usage": "list_payloads"
        },
        "generate_payload": {
            "func": lambda args: PayloadPlugin.generate_payload(args),
            "desc": "Generate a payload with optional parameters.",
            "usage": "generate_payload <payload_name> [key=value ...]"
        },
        "encode_payload": {
            "func": lambda args: PayloadPlugin.encode_payload(args),
            "desc": "Encode payload code (base64).",
            "usage": "encode_payload <code>"
        },
        "save_payload": {
            "func": lambda args: PayloadPlugin.save_payload(args),
            "desc": "Save generated payload to file.",
            "usage": "save_payload <code> [filename]"
        }
    }

    payload_dir = "modules/payloads"
    payloads = {}

    @classmethod
    def load_payloads(cls):
        cls.payloads.clear()
        if not os.path.exists(cls.payload_dir):
            return "[!] Payload directory does not exist."
        for file in os.listdir(cls.payload_dir):
            if file.endswith(".py") and file != "manager.py" and not file.startswith("__"):
                name = file[:-3]
                module = cls._load_module(name)
                if hasattr(module, "generate"):
                    cls.payloads[name] = module
        return f"[+] Loaded {len(cls.payloads)} payload(s)."

    @classmethod
    def _load_module(cls, name):
        path = os.path.join(cls.payload_dir, f"{name}.py")
        spec = importlib.util.spec_from_file_location(name, path)
        module = importlib.util.module_from_spec(spec)
        try:
            spec.loader.exec_module(module)
        except Exception:
            pass
        return module

    @classmethod
    def list_payloads(cls):
        cls.load_payloads()
        if not cls.payloads:
            return "[!] No payloads available."
        return "[*] Available payloads:\n - " + "\n - ".join(cls.payloads.keys())

    @classmethod
    def generate_payload(cls, args):
        if not args:
            return "[!] Usage: generate_payload <payload_name> [key=value ...]"
        name = args[0]
        if name not in cls.payloads:
            return f"[!] Payload '{name}' not found."
        kwargs = {}
        for pair in args[1:]:
            if '=' in pair:
                k, v = pair.split('=', 1)
                kwargs[k] = v
        try:
            code = cls.payloads[name].generate(**kwargs)
            return code or "[!] Payload generation failed."
        except Exception as e:
            return f"[!] Payload generation error: {e}"

    @classmethod
    def encode_payload(cls, args):
        if not args:
            return "[!] Usage: encode_payload <code>"
        code = " ".join(args)
        encoded = base64.b64encode(code.encode()).decode()
        return f"import base64\nexec(base64.b64decode('{encoded}').decode())"

    @classmethod
    def save_payload(cls, args):
        if not args:
            return "[!] Usage: save_payload <code> [filename]"
        code = args[0]
        filename = args[1] if len(args) > 1 else "intpayload.py"
        with open(filename, "w") as f:
            f.write(code)
        return f"[+] Payload saved to {filename}"